{"ast":null,"code":"var _jsxFileName = \"/Users/zowie/Desktop/Dragon_Tester/pages/editor.js\";\nvar __jsx = React.createElement;\n\n/* eslint-disable */\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport ObjPath from \"object-path\";\nimport * as Acorn from \"acorn\";\nimport { generate as generateJs } from \"escodegen\";\nimport { transform as babelTransform } from \"@babel/standalone\";\n\nfunction isReactNode(node) {\n  const type = node.type; //\"ExpressionStatement\"\n\n  const obj = ObjPath.get(node, \"expression.callee.object.name\");\n  const func = ObjPath.get(node, \"expression.callee.property.name\");\n  return type === \"ExpressionStatement\" && obj === \"React\" && func === \"createElement\";\n}\n\nexport function findReactNode(ast) {\n  const {\n    body\n  } = ast;\n  return body.find(isReactNode);\n}\nexport function createEditor(domElement, moduleResolver = () => null) {\n  function render(node) {\n    ReactDOM.render(node, domElement);\n  }\n\n  function require(moduleName) {\n    return moduleResolver(moduleName);\n  }\n\n  function getWrapperFunction(code) {\n    try {\n      // 1. transform code\n      const tcode = babelTransform(code, {\n        presets: [\"es2015\", \"react\"]\n      }).code; // 2. get AST\n\n      const ast = Acorn.parse(tcode, {\n        sourceType: \"module\"\n      }); // 3. find React.createElement expression in the body of program\n\n      const rnode = findReactNode(ast);\n\n      if (rnode) {\n        const nodeIndex = ast.body.indexOf(rnode); // 4. convert the React.createElement invocation to source and remove the trailing semicolon\n\n        const createElSrc = generateJs(rnode).slice(0, -1); // 5. transform React.createElement(...) to render(React.createElement(...)),\n        // where render is a callback passed from outside\n\n        const renderCallAst = Acorn.parse(`render(${createElSrc})`).body[0];\n        ast.body[nodeIndex] = renderCallAst;\n      } // 6. create a new wrapper function with all dependency as parameters\n\n\n      return new Function(\"React\", \"render\", \"require\", generateJs(ast));\n    } catch (ex) {\n      // in case of exception render the exception message\n      render(__jsx(\"pre\", {\n        style: {\n          color: \"red\"\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 64,\n          columnNumber: 14\n        }\n      }, ex.message));\n    }\n  }\n\n  return {\n    // returns transpiled code in a wrapper function which can be invoked later\n    compile(code) {\n      return getWrapperFunction(code);\n    },\n\n    // compiles and invokes the wrapper function\n    run(code) {\n      this.compile(code)(React, render, require);\n    },\n\n    // just compiles and returns the stringified wrapper function\n    getCompiledCode(code) {\n      return getWrapperFunction(code).toString();\n    }\n\n  };\n}","map":{"version":3,"sources":["/Users/zowie/Desktop/Dragon_Tester/pages/editor.js"],"names":["React","ReactDOM","ObjPath","Acorn","generate","generateJs","transform","babelTransform","isReactNode","node","type","obj","get","func","findReactNode","ast","body","find","createEditor","domElement","moduleResolver","render","require","moduleName","getWrapperFunction","code","tcode","presets","parse","sourceType","rnode","nodeIndex","indexOf","createElSrc","slice","renderCallAst","Function","ex","color","message","compile","run","getCompiledCode","toString"],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport ObjPath from \"object-path\";\n\nimport * as Acorn from \"acorn\";\n\nimport { generate as generateJs } from \"escodegen\";\nimport { transform as babelTransform } from \"@babel/standalone\";\n\nfunction isReactNode(node) {\n  const type = node.type; //\"ExpressionStatement\"\n  const obj = ObjPath.get(node, \"expression.callee.object.name\");\n  const func = ObjPath.get(node, \"expression.callee.property.name\");\n  return (\n    type === \"ExpressionStatement\" &&\n    obj === \"React\" &&\n    func === \"createElement\"\n  );\n}\n\nexport function findReactNode(ast) {\n  const { body } = ast;\n  return body.find(isReactNode);\n}\n\nexport function createEditor(domElement, moduleResolver = () => null) {\n  function render(node) {\n    ReactDOM.render(node, domElement);\n  }\n\n  function require(moduleName) {\n    return moduleResolver(moduleName);\n  }\n\n  function getWrapperFunction(code) {\n    try {\n      // 1. transform code\n      const tcode = babelTransform(code, { presets: [\"es2015\", \"react\"] }).code;\n\n      // 2. get AST\n      const ast = Acorn.parse(tcode, {\n        sourceType: \"module\",\n      });\n\n      // 3. find React.createElement expression in the body of program\n      const rnode = findReactNode(ast);\n\n      if (rnode) {\n        const nodeIndex = ast.body.indexOf(rnode);\n        // 4. convert the React.createElement invocation to source and remove the trailing semicolon\n        const createElSrc = generateJs(rnode).slice(0, -1);\n        // 5. transform React.createElement(...) to render(React.createElement(...)),\n        // where render is a callback passed from outside\n        const renderCallAst = Acorn.parse(`render(${createElSrc})`).body[0];\n\n        ast.body[nodeIndex] = renderCallAst;\n      }\n\n      // 6. create a new wrapper function with all dependency as parameters\n      return new Function(\"React\", \"render\", \"require\", generateJs(ast));\n    } catch (ex) {\n      // in case of exception render the exception message\n      render(<pre style={{ color: \"red\" }}>{ex.message}</pre>);\n    }\n  }\n\n  return {\n    // returns transpiled code in a wrapper function which can be invoked later\n    compile(code) {\n      return getWrapperFunction(code);\n    },\n\n    // compiles and invokes the wrapper function\n    run(code) {\n      this.compile(code)(React, render, require);\n    },\n\n    // just compiles and returns the stringified wrapper function\n    getCompiledCode(code) {\n      return getWrapperFunction(code).toString();\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}